#!/usr/bin/env python3

# *******************************************************
# Copyright (c) VMware, Inc. 2021. All Rights Reserved.
# SPDX-License-Identifier: MIT
# *******************************************************
# *
# * DISCLAIMER. THIS PROGRAM IS PROVIDED TO YOU "AS IS" WITHOUT
# * WARRANTIES OR CONDITIONS OF ANY KIND, WHETHER ORAL OR WRITTEN,
# * EXPRESS OR IMPLIED. THE AUTHOR SPECIFICALLY DISCLAIMS ANY IMPLIED
# * WARRANTIES OR CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY,
# * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.

"""Model and Query Classes for Vulnerability Assessment API"""

from cbc_sdk.base import (NewBaseModel, BaseQuery, QueryBuilder, QueryBuilderSupportMixin,
                          IterableQueryMixin, AsyncQueryMixin)
from cbc_sdk.errors import ApiError
import logging
import time

log = logging.getLogger(__name__)

""" Vulnerability models: """


class OrganizationalVulnerability(NewBaseModel):
    """Model for OrganizationalVulnerability"""
    urlobject = '/vulnerability/assessment/api/v1/orgs/{0}'
    swagger_meta_file = "workload/models/paginatedDeviceVulnerabilityList.yaml"
    url_additional = ""

    def __init__(self, cb):
        """
        Initialize the OrganizationalVulnerability object.

        Args:
            cb (BaseAPI): Reference to API object used to communicate with the server.
        """
        super(OrganizationalVulnerability, self).__init__(cb)
        self._full_init = True

    @classmethod
    def _query_implementation(cls, cb, **kwargs):
        """
        Returns the appropriate query object for this object type.

        Args:
            cb (BaseAPI): Reference to API object used to communicate with the server.
            **kwargs (dict): Not used, retained for compatibility.

        Returns:
            VulnerabilityQuery: The query object
        """
        return VulnerabilityQuery(cls, cb)


class VulnerabilitySummary(NewBaseModel):
    """Represents a vulnerability summary."""
    urlobject = "/vulnerability/assessment/api/v1/orgs/{0}"
    swagger_meta_file = "workload/models/organizationVulnerabilitySummary.yaml"
    url_additional = "/summary"

    VALID_SEVERITY = ["CRITICAL", "IMPORTANT", "MODERATE", "LOW"]

    def __init__(self, cb):
        """
        Initialize VulnerabilitySummary

        Args:
            cb (BaseAPI): Reference to API object used to communicate with the server.
        """
        super(VulnerabilitySummary, self).__init__(cb)
        self._full_init = True

    @classmethod
    def _query_implementation(cls, cb, **kwargs):
        """
        Returns the appropriate query object for this object type.

        Reusing VulnerabilityQuery, because it supports the same criteria fields

        Args:
            cb (BaseAPI): Reference to API object used to communicate with
            the server.
            **kwargs (dict): Not used, retained for compatibility.

        Returns:
            VulnerabilityQuery: The query object
        """
        return VulnerabilityQuery(cls, cb)

    @classmethod
    def get_vulnerability_summary(cls, cb, severity=None, vcenter_id=None):
        """
        Returns vulnerability summary at the organization level

        - if severity is provided, it is added as a query parameter
        - if vcenter_id is provided the vulnerabilities per vcenter_id are returned

        Args:
            cb (BaseAPI): Reference to API object used to communicate with the server.

        Returns:
            dictinary: monitored_assets and severity summary
        """
        query_params = {}
        if vcenter_id:
            url = "/vcenters/{}/vulnerabilities/summary".format(vcenter_id)
        else:
            url = "/vulnerabilities/summary"

        if severity and severity not in VulnerabilitySummary.VALID_SEVERITY:
            raise ApiError("Invalid severity")
        elif severity:
            query_params["severity"] = severity

        req_url = OrganizationalVulnerability.urlobject.format(
            cb.credentials.org_key) + url
        return cb.get_object(req_url, query_params)


class Vulnerability(NewBaseModel):
    """Vulnerability Model"""
    urlobject = '/vulnerability/assessment/api/v1'
    urlobject_single = '/vulnerability/assessment/api/v1/vulnerabilities/{}'
    swagger_meta_file = "workload/models/vulnerability.yaml"
    url_additional = ""
    primary_key = "cve_id"

    def __init__(self, cb, model_unique_id, initial_data=None):
        """
        Initialize the Vulnerability object.

        Args:
            cb (BaseAPI): Reference to API object used to communicate with the server.
            model_unique_id (str): ID of the alert represented.
            initial_data (dict): Initial data used to populate the alert.
        """
        super(Vulnerability, self).__init__(cb, model_unique_id, initial_data)
        if model_unique_id is not None and initial_data is None:
            self._refresh()
        self._full_init = True
        self._os_product_id = None

    def _refresh(self):
        """
        Rereads the object data from the server.

        Returns:
            bool: True if refresh was successful, False if not.
        """
        resp = self._cb.get_object(self._build_api_request_uri())
        resp['cve_id'] = self._model_unique_id
        self._info = resp
        self._last_refresh_time = time.time()
        return True

    def _build_api_request_uri(self, http_method="GET"):
        """
        Build the unique URL used to make requests for this object.

        Args:
            http_method (str): Not used; retained for compatibility.

        Returns:
            str: The URL used to make requests for this object.
        """
        return self.urlobject_single.format(self._model_unique_id)

    def affected_assets(self, os_product_id=None):
        """Returns a list of Vulnerability associated with device.

        Returns:
            Vulnerability ([Vulnerability]): List of Vulnerability in this device.
            The os_product_id is required parameter in the request
        """
        if os_product_id:
            self._os_product_id = os_product_id
            return AffectedAssetQuery(self, self._cb)
        else:
            raise ApiError("The os product id is required parameter")


class VulnerabilityQuery(BaseQuery, QueryBuilderSupportMixin,
                         IterableQueryMixin, AsyncQueryMixin):
    """Represents a query that is used to locate Vulnerabiltity objects."""
    VALID_DEVICE_TYPE = ["WORKLOAD", "ENDPOINT"]
    VALID_OS_TYPE = ["CENTOS", "RHEL", "SLES", "UBUNTU", "WINDOWS"]
    VALID_SEVERITY = ["CRITICAL", "IMPORTANT", "MODERATE", "LOW"]
    VALID_SYNC_TYPE = ["MANUAL", "SCHEDULED"]
    VALID_SYNC_STATUS = ["NOT_STARTED", "MATCHED", "ERROR", "NOT_MATCHED",
                         "NOT_SUPPORTED", "CANCELLED", "IN_PROGRESS", "ACTIVE",
                         "COMPLETED"]
    VALID_DIRECTIONS = ["ASC", "DESC"]

    def __init__(self, doc_class, cb):
        """
        Initialize the VulnerabilityQuery.

        Args:
            doc_class (class): The model class that will be returned by this query.
            cb (BaseAPI): Reference to API object used to communicate with the server.
        """
        self._doc_class = doc_class
        self._cb = cb
        self._count_valid = False
        super(BaseQuery, self).__init__()
        self._query_builder = QueryBuilder()
        self._criteria = {}
        self._sortcriteria = {}
        self._total_results = 0
        self._vcenter_specific = None

    # include separate method for the criteria
    def set_vcenter(self, vcenter_id):
        """Set the vcenter_id"""
        if vcenter_id:
            self._vcenter_specific = vcenter_id
        return self

    def set_device_type(self, device_type, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified device type.

        Args:
            device_type (string): device type.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if device_type not in VulnerabilityQuery.VALID_DEVICE_TYPE:
            raise ApiError("Invalid device type")
        self._update_criteria("device_type", device_type, operator)
        return self

    def set_highest_risk_score(self, highest_risk_score, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified highest_risk_score.

        Args:
            highest_risk_score (double): highest_risk_score.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if not highest_risk_score:
            raise ApiError("Invalid highest risk score")
        self._update_criteria("highest_risk_score", highest_risk_score, operator)
        return self

    def set_name(self, name, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified name.

        Args:
            name (string): name.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if not name:
            raise ApiError("Invalid name")
        self._update_criteria("name", name, operator)
        return self

    def set_os_arch(self, os_arch, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified os_arch.

        Args:
            os_arch (string): os_arch.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if not os_arch:
            raise ApiError("Invalid os architecture")
        self._update_criteria("os_arch", os_arch, operator)
        return self

    def set_os_name(self, os_name, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified os_name.

        Args:
            os_name (string): os_name.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if not os_name:
            raise ApiError("Invalid os name")
        self._update_criteria("os_name", os_name, operator)
        return self

    def set_os_type(self, os_type, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified os type.

        Args:
            os_type (string): os type.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if os_type not in VulnerabilityQuery.VALID_OS_TYPE:
            raise ApiError("Invalid os type")
        self._update_criteria("os_type", os_type, operator)
        return self

    def set_os_version(self, os_version, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified os_version.

        Args:
            os_version (string): os_version.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if not os_version:
            raise ApiError("Invalid os version")
        self._update_criteria("os_version", os_version, operator)
        return self

    def set_severity(self, severity, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified severity.

        Args:
            severity (string): severity.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if severity not in VulnerabilityQuery.VALID_SEVERITY:
            raise ApiError("Invalid severity")
        self._update_criteria("severity", severity, operator)
        return self

    def set_sync_type(self, sync_type, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified sync_type.

        Args:
            sync_type (string): sync_type.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if sync_type not in VulnerabilityQuery.VALID_SYNC_TYPE:
            raise ApiError("Invalid sync type")
        self._update_criteria("sync_type", sync_type, operator)
        return self

    def set_sync_status(self, sync_status, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified sync_status.

        Args:
            sync_status (string): sync_status.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if sync_status not in VulnerabilityQuery.VALID_SYNC_STATUS:
            raise ApiError("Invalid sync status")
        self._update_criteria("sync_status", sync_status, operator)
        return self

    def set_vm_id(self, vm_id, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified vm_id.

        Args:
            vm_id (string): vm_id.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if not vm_id:
            raise ApiError("Invalid vm id")
        self._update_criteria("vm_id", vm_id, operator)
        return self

    def set_vuln_count(self, vuln_count, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified vuln_count.

        Args:
            vuln_count (string): vuln_count.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if not vuln_count:
            raise ApiError("Invalid vuln count")
        self._update_criteria("vuln_count", vuln_count, operator)
        return self

    def set_last_sync_ts(self, last_sync_ts, operator):
        """
        Restricts the vulnerabilities that this query is performed on to the specified last_sync_ts.

        Args:
            last_sync_ts (string): last_sync_ts.

        Returns:
            VulnerabilityQuery: This instance.
        """
        if not last_sync_ts:
            raise ApiError("Invalid last_sync_ts")
        self._update_criteria("last_sync_ts", last_sync_ts, operator)
        return self

    """
        Including custom update_criteria, because the format is different:
        "criteria": {
            "property": {
                "value": "<string>",
                "operator": "<string>"
            }
        }
    """
    def _update_criteria(self, key, value, operator, overwrite=False):
        """
        Updates a list of criteria being collected for a query, by setting or appending items.

        Args:
            key (str): The property for the criteria item to be set.
            value (can be different types): the value for the criteria
            operator (str): any of the following types:
                - EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, IS_NULL,
                  IS_NOT_NULL, IS_TRUE, IS_FALSE, IN, NOT_IN, LIKE
            overwrite (bool): Overwrite the existing criteria for specified key

            The values are not lists, so if override is not allowed, disregard
            the change!
        """
        if self._criteria.get(key, None) is None or overwrite:
            self._criteria[key] = dict(value=value, operator=operator)

    def _build_request(self, from_row, max_rows, add_sort=True):
        """
        Creates the request body for an API call.

        Args:
            from_row (int): The row to start the query at.
            max_rows (int): The maximum number of rows to be returned.
            add_sort (bool): If True(default), the sort criteria will be added as part of the request.

        Returns:
            dict: The complete request body.
        """
        request = {"criteria": self._criteria, "query": self._query_builder._collapse(), "rows": 100}
        # Fetch 100 rows per page (instead of 10 by default) for better performance
        if from_row > 0:
            request["start"] = from_row
        if max_rows >= 0:
            request["rows"] = max_rows
        if add_sort and self._sortcriteria != {}:
            request["sort"] = [self._sortcriteria]
        return request

    def _build_url(self, tail_end):
        """
        Creates the URL to be used for an API call.

        Args:
            tail_end (str): String to be appended to the end of the generated URL.

        Returns:
            str: The complete URL.
        """
        if self._vcenter_specific:
            additional = "/vcenters/{}/devices/vulnerabilities".format(self._vcenter_specific)
        else:
            additional = "/devices/vulnerabilities"
        additional += self._doc_class.url_additional
        url = self._doc_class.urlobject.format(self._cb.credentials.org_key) + additional + tail_end
        return url

    def _count(self):
        """
        Returns the number of results from the run of this query.

        Returns:
            int: The number of results from the run of this query.
        """
        if self._count_valid:
            return self._total_results
        url = self._build_url("/_search")
        request = self._build_request(0, -1)
        resp = self._cb.post_object(url, body=request)
        result = resp.json()

        self._total_results = result["num_found"]
        self._count_valid = True

        return self._total_results

    def _perform_query(self, from_row=0, max_rows=-1):
        """
        Performs the query and returns the results of the query in an iterable fashion.

        Args:
            from_row (int): The row to start the query at (default 0).
            max_rows (int): The maximum number of rows to be returned (default -1, meaning "all").

        Returns:
            Iterable: The iterated query.
        """
        url = self._build_url("/_search")
        current = from_row
        numrows = 0
        still_querying = True
        while still_querying:
            request = self._build_request(current, max_rows)
            resp = self._cb.post_object(url, body=request)
            result = resp.json()

            self._total_results = result["num_found"]
            self._count_valid = True

            results = result.get("results", [])
            for item in results:
                yield item
                current += 1
                numrows += 1

                if max_rows > 0 and numrows == max_rows:
                    still_querying = False
                    break

            if current >= self._total_results:
                break

    def _run_async_query(self, context):
        """
        Executed in the background to run an asynchronous query.

        Args:
            context (object): Not used, always None.

        Returns:
            list: Result of the async query, which is then returned by the future.
        """
        url = self._build_url("/_search")
        request = self._build_request(0, -1)
        resp = self._cb.post_object(url, body=request)
        result = resp.json()
        self._total_results = result["num_found"]
        self._count_valid = True
        results = result.get("results", [])
        return [item for item in results]

    def sort_by(self, key, direction="ASC"):
        """
        Sets the sorting behavior on a query's results.

        Example:
            >>> cb.select(Vulnerabiltiy).sort_by("status")

        Args:
            key (str): The key in the schema to sort by.
            direction (str): The sort order, either "ASC" or "DESC".

        Returns:
            VulnerabilityQuery: This instance.

        Raises:
            ApiError: If an invalid direction value is passed.
        """
        if direction not in VulnerabilityQuery.VALID_DIRECTIONS:
            raise ApiError("invalid sort direction specified")
        self._sortcriteria = {"field": key, "order": direction}
        return self


class AffectedAssetQuery(VulnerabilityQuery):
    """Query Class for the Vulnerability"""

    def __init__(self, doc_class, cb):
        """
        Initialize the VulnerabilityQuery.

        Args:
            doc_class (class): The model class that will be returned by this query.
            cb (BaseAPI): Reference to API object used to communicate with the server.
        """
        self._doc_class = doc_class
        self._cb = cb
        self._count_valid = False
        super(BaseQuery, self).__init__()
        self._query_builder = QueryBuilder()
        self._criteria = {}
        self._sortcriteria = {}
        self._total_results = 0
        self._vcenter_specific = None

    def _build_url(self, tail_end):
        """
        Creates the URL to be used for an API call.

        Args:
            tail_end (str): String to be appended to the end of the generated URL.

        Returns:
            str: The complete URL.
        """
        if self._vcenter_specific:
            additional = "/vcenters/{}/vulnerabilities/{}/devices".format(self._vcenter_specific,
                                                                          self._doc_class._model_unique_id)
        else:
            additional = "/vulnerabilities/{}/devices".format(self._doc_class._model_unique_id)
        additional += self._doc_class.url_additional
        url = (self._doc_class.urlobject + '/orgs/{}').format(self._cb.credentials.org_key) + additional + tail_end
        return url

    def _build_request(self, from_row, max_rows, add_sort=True):
        """
        Creates the request body for an API call.

        Args:
            from_row (int): The row to start the query at.
            max_rows (int): The maximum number of rows to be returned.
            add_sort (bool): If True(default), the sort criteria will be added as part of the request.

        Returns:
            dict: The complete request body.
        """
        request = {
            "os_product_id": self._doc_class._os_product_id,
            "criteria": self._criteria,
            "query": self._query_builder._collapse(),
            "rows": 100}
        # Fetch 100 rows per page (instead of 10 by default) for better performance
        if from_row > 0:
            request["start"] = from_row
        if max_rows >= 0:
            request["rows"] = max_rows
        if add_sort and self._sortcriteria != {}:
            request["sort"] = [self._sortcriteria]
        return request

    def _perform_query(self, from_row=0, max_rows=-1):
        """
        Performs the query and returns the results of the query in an iterable fashion.

        Args:
            from_row (int): The row to start the query at (default 0).
            max_rows (int): The maximum number of rows to be returned (default -1, meaning "all").

        Returns:
            Iterable: The iterated query.
        """
        url = self._build_url("")
        current = from_row
        numrows = 0
        still_querying = True
        while still_querying:
            request = self._build_request(current, max_rows)
            resp = self._cb.post_object(url, body=request)
            result = resp.json()

            self._total_results = result["num_found"]
            self._count_valid = True

            results = result.get("results", [])
            for item in results:
                yield item
                current += 1
                numrows += 1

                if max_rows > 0 and numrows == max_rows:
                    still_querying = False
                    break

            if current >= self._total_results:
                break

    def _run_async_query(self, context):
        """
        Executed in the background to run an asynchronous query.

        Args:
            context (object): Not used, always None.

        Returns:
            list: Result of the async query, which is then returned by the future.
        """
        url = self._build_url("")
        request = self._build_request(0, -1)
        resp = self._cb.post_object(url, body=request)
        result = resp.json()
        self._total_results = result["num_found"]
        self._count_valid = True
        results = result.get("results", [])
        return [item for item in results]

    def _count(self):
        """
        Returns the number of results from the run of this query.

        Returns:
            int: The number of results from the run of this query.
        """
        if self._count_valid:
            return self._total_results
        url = self._build_url("")
        request = self._build_request(0, -1)
        resp = self._cb.post_object(url, body=request)
        result = resp.json()

        self._total_results = result["num_found"]
        self._count_valid = True

        return self._total_results
